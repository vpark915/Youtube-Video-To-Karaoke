{"version":3,"sources":["../src/Downloader.ts","../src/FormatConverter.ts","../src/utils.ts","../src/SongTagsSearch.ts","../src/main.ts","../package.json"],"sourcesContent":["import os from 'os';\nimport path from 'path';\n\nimport NodeID3 from 'node-id3';\nimport ytdl from 'ytdl-core';\nimport type { videoInfo as VideoInfo } from 'ytdl-core';\n\nimport { FormatConverter } from './FormatConverter';\nimport { SongTagsSearch } from './SongTagsSearch';\nimport { YtdlMp3Error, isDirectory, removeParenthesizedText } from './utils';\n\nexport type DownloaderOptions = {\n  getTags?: boolean;\n  outputDir?: string;\n  verifyTags?: boolean;\n};\n\nexport class Downloader {\n  static defaultDownloadsDir = path.join(os.homedir(), 'Downloads');\n\n  getTags: boolean;\n  outputDir: string;\n  verifyTags: boolean;\n\n  constructor({ getTags, outputDir, verifyTags }: DownloaderOptions) {\n    this.outputDir = outputDir ?? Downloader.defaultDownloadsDir;\n    this.getTags = Boolean(getTags);\n    this.verifyTags = Boolean(verifyTags);\n  }\n\n  async downloadSong(url: string): Promise<string> {\n    if (!isDirectory(this.outputDir)) {\n      throw new YtdlMp3Error(`Not a directory: ${this.outputDir}`);\n    }\n    const videoInfo = await ytdl.getInfo(url).catch((error) => {\n      throw new YtdlMp3Error(`Failed to fetch info for video with URL: ${url}`, {\n        cause: error\n      });\n    });\n\n    const formatConverter = new FormatConverter();\n    const songTagsSearch = new SongTagsSearch(videoInfo.videoDetails);\n\n    const outputFile = this.getOutputFile(videoInfo.videoDetails.title);\n    const videoData = await this.downloadVideo(videoInfo);\n\n    formatConverter.videoToAudio(videoData, outputFile);\n    if (this.getTags) {\n      const songTags = await songTagsSearch.search(this.verifyTags);\n      NodeID3.write(songTags, outputFile);\n    }\n\n    console.log(`Done! Output file: ${outputFile}`);\n    return outputFile;\n  }\n\n  /** Returns the content from the video as a buffer */\n  private async downloadVideo(videoInfo: VideoInfo): Promise<Buffer> {\n    const buffers: Buffer[] = [];\n    const stream = ytdl.downloadFromInfo(videoInfo, { quality: 'highestaudio' });\n    return new Promise((resolve, reject) => {\n      stream.on('data', (chunk: Buffer) => {\n        buffers.push(chunk);\n      });\n      stream.on('end', () => {\n        resolve(Buffer.concat(buffers));\n      });\n      stream.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /** Returns the absolute path to the audio file to be downloaded */\n  private getOutputFile(videoTitle: string): string {\n    const baseFileName = removeParenthesizedText(videoTitle)\n      .replace(/[^a-z0-9]/gi, '_')\n      .split('_')\n      .filter((element) => element)\n      .join('_')\n      .toLowerCase();\n    return path.join(this.outputDir, baseFileName + '.mp3');\n  }\n}\n","import cp from 'child_process';\nimport fs from 'fs';\n\nimport ffmpeg from 'ffmpeg-static';\n\nimport { YtdlMp3Error } from './utils';\n\nexport class FormatConverter {\n  private readonly ffmpegBinary: string;\n\n  constructor() {\n    if (!ffmpeg) {\n      throw new YtdlMp3Error('Failed to resolve ffmpeg binary');\n    }\n    this.ffmpegBinary = ffmpeg;\n  }\n\n  videoToAudio(videoData: Buffer, outputFile: string): void {\n    if (fs.existsSync(outputFile)) {\n      throw new YtdlMp3Error(`Output file already exists: ${outputFile}`);\n    }\n    cp.execSync(`${this.ffmpegBinary} -loglevel 24 -i pipe:0 -vn -sn -c:a mp3 -ab 192k ${outputFile}`, {\n      input: videoData\n    });\n  }\n}\n","import fs from 'fs';\nimport readline from 'readline';\n\n/**\n * Removes content within square brackets or parentheses, including the brackets and\n * parentheses themselves, along with any surrounding whitespace, from the given string.\n *\n * @param input the input string from which to remove content within brackets and parentheses.\n * @returns a new string with content within brackets and parentheses removed.\n */\nexport function removeParenthesizedText(s: string): string {\n  // This loop is to handle nested nested brackets (see test for examples)\n  const regex = /\\s*([[(][^[\\]()]*[\\])])\\s*/g;\n  while (regex.test(s)) {\n    s = s.replace(regex, '');\n  }\n  return s;\n}\n\n/**\n * Checks if the given path corresponds to a directory.\n *\n * @param path - the path to check.\n * @returns `true` if the path exists and is a directory, `false` otherwise.\n */\nexport function isDirectory(path: string): boolean {\n  return fs.existsSync(path) && fs.lstatSync(path).isDirectory();\n}\n\n/**\n * Prompts the user for input via stdin and returns a promise that resolves to the user's input.\n *\n * @param prompt - the prompt text displayed to the user.\n * @param defaultInput - optional default input pre-filled in the prompt.\n * @returns a promise that resolves to the user's input\n */\nexport async function userInput(prompt: string, defaultInput?: string): Promise<string> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n  return new Promise((resolve, reject) => {\n    rl.question(prompt, (response) => {\n      rl.close();\n      if (response) {\n        resolve(response);\n      } else {\n        reject(new YtdlMp3Error('Invalid response: ' + response));\n      }\n    });\n    rl.write(defaultInput ?? '');\n  });\n}\n\n/**\n * Custom error class representing unrecoverable errors intentionally thrown by ytdl-mp3\n */\nexport class YtdlMp3Error extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = 'YtdlMp3Error';\n  }\n}\n","import axios, { type AxiosError } from 'axios';\nimport type { MoreVideoDetails } from 'ytdl-core';\n\nimport { YtdlMp3Error, removeParenthesizedText, userInput } from './utils';\n\nexport type SearchResult = {\n  artistName: string;\n  artworkUrl100: string;\n  trackName: string;\n};\n\nexport type SearchData = {\n  resultCount: number;\n  results: SearchResult[];\n};\n\nexport type AlbumArt = {\n  description: string;\n  imageBuffer: Buffer;\n  mime: string;\n  type: {\n    id: number;\n    name: string;\n  };\n};\n\nexport type SongTags = {\n  artist: string;\n  image: AlbumArt;\n  title: string;\n};\n\nexport class SongTagsSearch {\n  private searchTerm: string;\n  private url: URL;\n\n  constructor(videoDetails: MoreVideoDetails) {\n    this.searchTerm = removeParenthesizedText(videoDetails.title);\n    this.url = new URL('https://itunes.apple.com/search?');\n    this.url.searchParams.set('media', 'music');\n    this.url.searchParams.set('term', this.searchTerm);\n  }\n\n  async search(verify = false): Promise<SongTags> {\n    console.log(`Attempting to query iTunes API with the following search term: ${this.searchTerm}`);\n    const searchResults = await this.fetchResults();\n    const result = verify ? await this.getVerifiedResult(searchResults) : searchResults[0]!;\n    const artworkUrl = result.artworkUrl100.replace('100x100bb.jpg', '600x600bb.jpg');\n    const albumArt = await this.fetchAlbumArt(artworkUrl);\n    return {\n      artist: result.artistName,\n      image: {\n        description: 'Album Art',\n        imageBuffer: albumArt,\n        mime: 'image/png',\n        type: {\n          id: 3,\n          name: 'front cover'\n        }\n      },\n      title: result.trackName\n    };\n  }\n\n  private async fetchAlbumArt(url: string): Promise<Buffer> {\n    return axios\n      .get(url, { responseType: 'arraybuffer' })\n      .then((response) => Buffer.from(response.data as string, 'binary'))\n      .catch(() => {\n        throw new YtdlMp3Error('Failed to fetch album art from endpoint: ' + url);\n      });\n  }\n\n  private async fetchResults(): Promise<SearchResult[]> {\n    const response = await axios.get<SearchData>(this.url.href).catch((error: AxiosError) => {\n      if (error.response?.status) {\n        throw new YtdlMp3Error(`Call to iTunes API returned status code ${error.response.status}`);\n      }\n      throw new YtdlMp3Error('Call to iTunes API failed and did not return a status');\n    });\n\n    if (response.data.resultCount === 0) {\n      throw new YtdlMp3Error('Call to iTunes API did not return any results');\n    }\n\n    return response.data.results;\n  }\n\n  private async getVerifiedResult(searchResults: SearchResult[]): Promise<SearchResult> {\n    for (const result of searchResults) {\n      console.log('The following tags were extracted from iTunes:');\n      console.log('Title: ' + result.trackName);\n      console.log('Artist: ' + result.artistName);\n\n      const validResponses = ['Y', 'YES', 'N', 'NO'];\n      let userSelection = (await userInput('Please verify (Y/N): ')).toUpperCase();\n      while (!validResponses.includes(userSelection)) {\n        console.error('Invalid selection, try again!');\n        userSelection = (await userInput('Please verify (Y/N): ')).toUpperCase();\n      }\n      if (userSelection === 'Y' || userSelection === 'YES') {\n        return result;\n      }\n    }\n    throw new YtdlMp3Error('End of results');\n  }\n}\n","import { Command } from 'commander';\n\nimport { description, name, version } from '../package.json';\nimport { Downloader } from './Downloader';\nimport { YtdlMp3Error } from './utils';\n\nexport async function main() {\n  const program = new Command();\n  program.name(name);\n  program.description(description);\n  program.version(version);\n  program.allowExcessArguments(false);\n  program.argument('<url>', 'url of video to download');\n  program.option('-o --output-dir <path>', 'path to output directory', Downloader.defaultDownloadsDir);\n  program.option('-n --no-get-tags', 'skip extracting/applying id3 tags');\n  program.option('-v --verify-tags', 'verify id3 tags fetched from itunes');\n  program.option('--verbose', 'enable verbose mode');\n  program.parse();\n\n  const options = program.opts();\n  try {\n    const downloader = new Downloader(options);\n    await downloader.downloadSong(program.args[0]!);\n  } catch (err) {\n    if (err instanceof YtdlMp3Error) {\n      if (options['verbose']) {\n        console.error(err.cause);\n        console.error(err.stack);\n      }\n      console.error(`ERROR: ${err.message}`);\n      process.exit(1);\n    }\n    throw err;\n  }\n}\n","{\n  \"name\": \"ytdl-mp3\",\n  \"type\": \"module\",\n  \"version\": \"4.0.0\",\n  \"packageManager\": \"pnpm@9.3.0\",\n  \"description\": \"An NPM package to facilitate downloading music from YouTube, including automatic retrieval of ID3 tags and album art via the iTunes public API.\",\n  \"author\": \"Joshua Unrau\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/joshunrau/ytdl-mp3#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/joshunrau/ytdl-mp3.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/joshunrau/ytdl-mp3/issues\"\n  },\n  \"keywords\": [\n    \"youtube\",\n    \"download\",\n    \"mp3\",\n    \"music\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    }\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"bin\": {\n    \"ytdl-mp3\": \"./bin/ytdl-mp3.cjs\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"bin\",\n    \"dist\",\n    \"package.json\"\n  ],\n  \"engines\": {\n    \"node\": \">=20.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"format\": \"prettier --write src\",\n    \"lint\": \"tsc && eslint --fix src\",\n    \"prepare\": \"husky\",\n    \"test\": \"vitest\",\n    \"test:coverage\": \"vitest --coverage\"\n  },\n  \"dependencies\": {\n    \"axios\": \"^1.7.2\",\n    \"commander\": \"^12.1.0\",\n    \"ffmpeg-static\": \"^5.2.0\",\n    \"node-id3\": \"^0.2.6\",\n    \"ytdl-core\": \"4.11.5\"\n  },\n  \"devDependencies\": {\n    \"@commitlint/cli\": \"^19.3.0\",\n    \"@commitlint/config-conventional\": \"^19.2.2\",\n    \"@joshunrau/eslint-config\": \"^4.3.3\",\n    \"@joshunrau/prettier-config\": \"^0.4.0\",\n    \"@joshunrau/semantic-release\": \"^0.1.4\",\n    \"@joshunrau/tsconfig\": \"^0.0.3\",\n    \"@types/ffmpeg-static\": \"^3.0.3\",\n    \"@types/node\": \"^20.14.5\",\n    \"@vitest/coverage-v8\": \"^2.0.4\",\n    \"eslint\": \"^8.57.0\",\n    \"husky\": \"^9.1.3\",\n    \"prettier\": \"^3.3.3\",\n    \"tsup\": \"^8.2.3\",\n    \"typescript\": \"~5.5.4\",\n    \"vitest\": \"^2.0.4\"\n  },\n  \"prettier\": \"@joshunrau/prettier-config\",\n  \"commitlint\": {\n    \"extends\": [\n      \"@commitlint/config-conventional\"\n    ]\n  },\n  \"release\": {\n    \"extends\": [\n      \"@joshunrau/semantic-release\"\n    ]\n  }\n}\n"],"mappings":"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","names":["fs","path","fs"]}