// src/Downloader.ts
import os from "os";
import path from "path";
import NodeID3 from "node-id3";
import ytdl from "ytdl-core";

// src/FormatConverter.ts
import cp from "child_process";
import fs2 from "fs";
import ffmpeg from "ffmpeg-static";

// src/utils.ts
import fs from "fs";
import readline from "readline";
function removeParenthesizedText(s) {
  const regex = /\s*([[(][^[\]()]*[\])])\s*/g;
  while (regex.test(s)) {
    s = s.replace(regex, "");
  }
  return s;
}
function isDirectory(path2) {
  return fs.existsSync(path2) && fs.lstatSync(path2).isDirectory();
}
async function userInput(prompt, defaultInput) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve, reject) => {
    rl.question(prompt, (response) => {
      rl.close();
      if (response) {
        resolve(response);
      } else {
        reject(new YtdlMp3Error("Invalid response: " + response));
      }
    });
    rl.write(defaultInput ?? "");
  });
}
var YtdlMp3Error = class extends Error {
  constructor(message, options) {
    super(message, options);
    this.name = "YtdlMp3Error";
  }
};

// src/FormatConverter.ts
var FormatConverter = class {
  ffmpegBinary;
  constructor() {
    if (!ffmpeg) {
      throw new YtdlMp3Error("Failed to resolve ffmpeg binary");
    }
    this.ffmpegBinary = ffmpeg;
  }
  videoToAudio(videoData, outputFile) {
    if (fs2.existsSync(outputFile)) {
      throw new YtdlMp3Error(`Output file already exists: ${outputFile}`);
    }
    cp.execSync(`${this.ffmpegBinary} -loglevel 24 -i pipe:0 -vn -sn -c:a mp3 -ab 192k ${outputFile}`, {
      input: videoData
    });
  }
};

// src/SongTagsSearch.ts
import axios from "axios";
var SongTagsSearch = class {
  searchTerm;
  url;
  constructor(videoDetails) {
    this.searchTerm = removeParenthesizedText(videoDetails.title);
    this.url = new URL("https://itunes.apple.com/search?");
    this.url.searchParams.set("media", "music");
    this.url.searchParams.set("term", this.searchTerm);
  }
  async search(verify = false) {
    console.log(`Attempting to query iTunes API with the following search term: ${this.searchTerm}`);
    const searchResults = await this.fetchResults();
    const result = verify ? await this.getVerifiedResult(searchResults) : searchResults[0];
    const artworkUrl = result.artworkUrl100.replace("100x100bb.jpg", "600x600bb.jpg");
    const albumArt = await this.fetchAlbumArt(artworkUrl);
    return {
      artist: result.artistName,
      image: {
        description: "Album Art",
        imageBuffer: albumArt,
        mime: "image/png",
        type: {
          id: 3,
          name: "front cover"
        }
      },
      title: result.trackName
    };
  }
  async fetchAlbumArt(url) {
    return axios.get(url, { responseType: "arraybuffer" }).then((response) => Buffer.from(response.data, "binary")).catch(() => {
      throw new YtdlMp3Error("Failed to fetch album art from endpoint: " + url);
    });
  }
  async fetchResults() {
    const response = await axios.get(this.url.href).catch((error) => {
      if (error.response?.status) {
        throw new YtdlMp3Error(`Call to iTunes API returned status code ${error.response.status}`);
      }
      throw new YtdlMp3Error("Call to iTunes API failed and did not return a status");
    });
    if (response.data.resultCount === 0) {
      throw new YtdlMp3Error("Call to iTunes API did not return any results");
    }
    return response.data.results;
  }
  async getVerifiedResult(searchResults) {
    for (const result of searchResults) {
      console.log("The following tags were extracted from iTunes:");
      console.log("Title: " + result.trackName);
      console.log("Artist: " + result.artistName);
      const validResponses = ["Y", "YES", "N", "NO"];
      let userSelection = (await userInput("Please verify (Y/N): ")).toUpperCase();
      while (!validResponses.includes(userSelection)) {
        console.error("Invalid selection, try again!");
        userSelection = (await userInput("Please verify (Y/N): ")).toUpperCase();
      }
      if (userSelection === "Y" || userSelection === "YES") {
        return result;
      }
    }
    throw new YtdlMp3Error("End of results");
  }
};

// src/Downloader.ts
var Downloader = class _Downloader {
  static defaultDownloadsDir = path.join(os.homedir(), "Downloads");
  getTags;
  outputDir;
  verifyTags;
  constructor({ getTags, outputDir, verifyTags }) {
    this.outputDir = outputDir ?? _Downloader.defaultDownloadsDir;
    this.getTags = Boolean(getTags);
    this.verifyTags = Boolean(verifyTags);
  }
  async downloadSong(url) {
    if (!isDirectory(this.outputDir)) {
      throw new YtdlMp3Error(`Not a directory: ${this.outputDir}`);
    }
    const videoInfo = await ytdl.getInfo(url).catch((error) => {
      throw new YtdlMp3Error(`Failed to fetch info for video with URL: ${url}`, {
        cause: error
      });
    });
    const formatConverter = new FormatConverter();
    const songTagsSearch = new SongTagsSearch(videoInfo.videoDetails);
    const outputFile = this.getOutputFile(videoInfo.videoDetails.title);
    const videoData = await this.downloadVideo(videoInfo);
    formatConverter.videoToAudio(videoData, outputFile);
    if (this.getTags) {
      const songTags = await songTagsSearch.search(this.verifyTags);
      NodeID3.write(songTags, outputFile);
    }
    console.log(`Done! Output file: ${outputFile}`);
    return outputFile;
  }
  /** Returns the content from the video as a buffer */
  async downloadVideo(videoInfo) {
    const buffers = [];
    const stream = ytdl.downloadFromInfo(videoInfo, { quality: "highestaudio" });
    return new Promise((resolve, reject) => {
      stream.on("data", (chunk) => {
        buffers.push(chunk);
      });
      stream.on("end", () => {
        resolve(Buffer.concat(buffers));
      });
      stream.on("error", (err) => {
        reject(err);
      });
    });
  }
  /** Returns the absolute path to the audio file to be downloaded */
  getOutputFile(videoTitle) {
    const baseFileName = removeParenthesizedText(videoTitle).replace(/[^a-z0-9]/gi, "_").split("_").filter((element) => element).join("_").toLowerCase();
    return path.join(this.outputDir, baseFileName + ".mp3");
  }
};

// src/main.ts
import { Command } from "commander";

// package.json
var name = "ytdl-mp3";
var version = "4.0.0";
var description = "An NPM package to facilitate downloading music from YouTube, including automatic retrieval of ID3 tags and album art via the iTunes public API.";

// src/main.ts
async function main() {
  const program = new Command();
  program.name(name);
  program.description(description);
  program.version(version);
  program.allowExcessArguments(false);
  program.argument("<url>", "url of video to download");
  program.option("-o --output-dir <path>", "path to output directory", Downloader.defaultDownloadsDir);
  program.option("-n --no-get-tags", "skip extracting/applying id3 tags");
  program.option("-v --verify-tags", "verify id3 tags fetched from itunes");
  program.option("--verbose", "enable verbose mode");
  program.parse();
  const options = program.opts();
  try {
    const downloader = new Downloader(options);
    await downloader.downloadSong(program.args[0]);
  } catch (err) {
    if (err instanceof YtdlMp3Error) {
      if (options["verbose"]) {
        console.error(err.cause);
        console.error(err.stack);
      }
      console.error(`ERROR: ${err.message}`);
      process.exit(1);
    }
    throw err;
  }
}
export {
  Downloader,
  FormatConverter,
  SongTagsSearch,
  YtdlMp3Error,
  main
};
//# sourceMappingURL=index.js.map